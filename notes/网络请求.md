##### Http、TCP、UDP

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。
网络层有IP协议，传输层中有TCP协议与UDP协议，应用层有FTP、HTTP DNS
socket只是一种连接模式，面向的两种协议，基于流的TCP，基于用户数据包的UDP


### square/okhttp.git: Socket连接

0. 首先明确概念
https://github.com/square/okhttp/wiki/Calls 

OkHttpClient,Request,Call,Response,Interceptor
```
// 异步Post请求：
private void postAsynHttp() {
     mOkHttpClient=new OkHttpClient();
     RequestBody formBody = new FormBody.Builder()
             .add("size", "10")
             .build();
     Request request = new Request.Builder()
             .url("http://api.1-blog.com/biz/bizserver/article/list.do")
             .post(formBody)
             .build();
     Call call = mOkHttpClient.newCall(request);
     // enqueue 异步
     call.enqueue(new Callback() {
         @Override
         public void onFailure(Call call, IOException e) {
         }
         @Override
         public void onResponse(Call call, Response response) throws IOException {
             String str = response.body().string();
             Log.i("wangshu", str);
             runOnUiThread(new Runnable() {
                 @Override
                 public void run() {
                     Toast.makeText(getApplicationContext(), "请求成功", Toast.LENGTH_SHORT).show();
                 }
             });
         }
     });
 }
```

call.enqueue(Callback c)执行了
```
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
```
把AsyncCall扔给了Dispatcher,而AsyncCall是RealCall的内部类，继承了Runnable，封装了Call,Callback,Request.

1. Dispatcher  
[Dispatcher](
https://github.com/square/okhttp/blob/c358656c8799d30fd422448153e99a5dd37e298a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
),主要用于控制并发的请求  

```
/** 最大并发请求数*/
private int maxRequests = 64;
/** 每个主机最大请求数*/
private int maxRequestsPerHost = 5;
/** 消费者线程池 */
private ExecutorService executorService;
/** 将要运行的异步请求队列 */
private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
/**正在运行的异步请求队列 */
private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
/** 正在运行的同步请求队列 */
private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();

// executorService() 线程池+阻塞队列+线程工厂  
 executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),Util.threadFactory("OkHttp Dispatcher", false));

// 请求数超过64，请求主机数小于5，加入到readyAsyncCalls中进行缓存等待
// runningAsyncCalls，readyAsyncCalls是Deque双端队列，
 synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
    runningAsyncCalls.add(call);
    executorService().execute(call); //在线程池中执行Runnable
  } else {
    readyAsyncCalls.add(call);
  }
}
```

AsyncCall是Runnable，它的run()方法调用了execute()，启动拦截器链式执行当前Call，然后把下一个Call扔进线程池。
```

    @Override protected void execute() {
      boolean signalledCallback = false;
      try {
          // 执行一堆Interceptor，得到Response
        Response response = getResponseWithInterceptorChain();
        if (retryAndFollowUpInterceptor.isCanceled()) {
          signalledCallback = true;
          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
        } else {
          signalledCallback = true;
          responseCallback.onResponse(RealCall.this, response);
        }
      } catch (IOException e) {
        if (signalledCallback) {
          // Do not signal the callback twice!
          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
        } else {
          eventListener.callFailed(RealCall.this, e);
          responseCallback.onFailure(RealCall.this, e);
        }
      } finally {
          // 最后，从runningAsyncCalls队列移除，然后取出下一个扔进线程池
        client.dispatcher().finished(this);
      }
    }
```

3 RealCall :自定义的拦截器（可以header,log,https），重试拦截器，缓存拦截器，连接拦截器。。

```
  Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List<Interceptor> interceptors = new ArrayList<>();
    ／／用户可定义的
    interceptors.addAll(client.interceptors());
    //重试
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    //缓存
    interceptors.add(new CacheInterceptor(client.internalCache()));
    //http连接
    interceptors.add(new ConnectInterceptor(client));
    //重定向之类
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
//the last interceptor所以拦截器链的trick是最后一个拦截器是真正的网络请求
    interceptors.add(new CallServerInterceptor(forWebSocket));
    Interceptor.Chain chain = new RealInterceptorChain(
        interceptors, null, null, null, 0, originalRequest);
    // 拦截器链式执行
    return chain.proceed(originalRequest);
  }
```

4 retryAndFollowUpInterceptor 重试

4 CacheInterceptor 缓存
如果从缓存取了response，怎么中断拦截器链的？

```
    // 不进行网络请求，而且缓存可以使用，直接返回缓存
    // 没有执行chain.proceed()，所以拦截链中断
    if (networkRequest == null) {
      return cacheResponse.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build();
    }

    ...

    networkResponse = chain.proceed(networkRequest);

```
final DiskLruCache cache;

4 CallServerInterceptor，真正的网络请求
httpCodec.createRequestBody(request, request.body().contentLength())
httpCodec.openResponseBody(response)

5 责任链模式

 https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F 

https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/chain-of-responsibility/AigeStudio ViewGroup事件传递

每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。

这里有个crush：interface Interceptor {

    if (response == null) {
      throw new NullPointerException("interceptor " + interceptor + " returned null");
    }
解决：你自定义的Interceptor，要把异常抛出来 intercept(Chain chain) throws IOException
6 http://www.jianshu.com/p/7b29b89cd7b5 

7 OKio

8 https://publicobject.com/2016/07/03/the-last-httpurlconnection/ 作者之一 比较HttpURLConnection

9 应用

http://www.tuicool.com/articles/3eiM3aI  利用 OkHttp Interceptor 模拟数据

10 封装库

11 复用连接池  
StreamAllocation.java

## square/retrofit.git

https://github.com/square/retrofit/wiki/Retrofit-Tutorials 

0 概念 Retrofit is pluggable  

动态代理
```
public <T> T create(final Class<T> service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();
          @Override public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            ServiceMethod<Object, Object> serviceMethod =
                (ServiceMethod<Object, Object>) loadServiceMethod(method);
            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
            return serviceMethod.callAdapter.adapt(okHttpCall);
          }
        });
  }
```
ServiceMethod封装了：
* Call Adapters ： com.squareup.retrofit2:adapter-rxjava2，以RxJavaCallAdapter为例，把一个Call转换为Observable。Observable<?> observable = Observable.create(func);
* Converters：com.squareup.retrofit2:converter-gson
* 用Call包装了Request，实现类OkHttpCall
* 你定义的service interface中的方法，注解／返回类型／参数

1 Response结果能在UI线程直接使用吗？

```
  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
    ResponseBody rawBody = rawResponse.body();
    // Remove the body's source (the only stateful object) so we can pass the response along.
    rawResponse = rawResponse.newBuilder()
        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
        .build();
    int code = rawResponse.code();

    if (code < 200 || code >= 300) {／／错误码
      try {
        // Buffer the entire body to avoid future I/O.
        ResponseBody bufferedBody = Utils.buffer(rawBody);
        return Response.error(bufferedBody, rawResponse);
      } finally {
        rawBody.close();
      }
    }
    if (code == 204 || code == 205) {／／成功，但没有响应体
      rawBody.close();
      return Response.success(null, rawResponse);
    }
    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
    try {
      T body = serviceMethod.toResponse(catchingBody);
      return Response.success(body, rawResponse);／／成功，有响应体
    } catch (RuntimeException e) {
      // If the underlying source threw an exception, propagate that rather than indicating it was
      // a runtime exception.
      catchingBody.throwIfCaught();
      throw e;
    }
  }
```

跟RxJavaCallAdapterFactory并列的默认加入的ExecutorCallAdapterFactory，它的callbackExecutor是MainThreadExecutor，也就是一个handler，用来把响应结果回调给UI线程。


2 来看Retrofit.Builder中的参数：

okhttp3.Call.Factory callFactory：真正处理请求的对象，默认是okhttp3。

HttpUrl baseUrl：请求的根地址。

List<Converter.Factory> converterFactories：解析器，负责解析请求的注解和应答的数据源。

List<CallAdapter.Factory> adapterFactories：执行请求的单元，默认是ExecutorCallAdapterFactory。

Executor callbackExecutor：操作请求的单元，默认是MainThreadExecutor。

boolean validateEagerly：是否提前执行方法参数注解的解析。


3 使用方式

Retrofit.create(final Class<T>service);//

        每个类都是Class的范性

        service必须是接口，不能有继承

@GET("/api/4/news/latest")

    Observable<Object> getLastestNews(Callback callback);//错误写法

   返回void +无Callback参//也是错误写法

Must have return type or Callback as last argument。//要么要么

正确： 

  返回void ＋ 最后一个参数为Callback+ 必须指定泛型

  返回非void ＋ 没有Callback参数

这两种写法都是异步的，会启动一个叫Retrofit-Idle的线程(它底层用了OkhttpThreadPool)，

4 动态代理  

https://mp.weixin.qq.com/s?__biz=MzIxOTI1NTk5Nw==&mid=2650047517&idx=1&sn=85d88950bfda21106c58be536cdfc9cc&chksm=8fde21cfb8a9a8d946c1276f4c6e5374b167eb11168428333213c4164264d840bd38473f9d02&scene=21#wechat_redirect 
因为Proxy.newProxyInstance()的第二个参数，所以你知道为什么service必须是接口。
可以干很多事：无痛埋点。。

======

Volley    生产者消费者

NetworkDispatcher/ExecutorDelivery





Volley 源码解析

http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90

http://blog.csdn.net/column/details/yuan-android-net.html

https://android.googlesource.com/platform/frameworks/volley/

https://github.com/mcxiaoke/android-volley

http://www.jianshu.com/p/9e17727f31a1 

1 整个流程

Volley中的线程交互

你知道或者被告知，request是新线程异步的，onResponse是UI线程的，但是为什么呢？来扒一扒。

涉及到Volley中的这几个实现类：

Volley	入口类

RequestQueue	

NetworkDispatcher extends Thread

ExecutorDelivery implements ResponseDelivery

然后一个Request实现，比如StringRequest

00 

 newRequestQueue();

 queue.add(request);		//使用者往队列加

Volley

01  queue.start();

RequestQueue

02  

记录一个UI线程的Handler

    public RequestQueue(Cache cache, Network network, int threadPoolSize) {

        this(cache, network, threadPoolSize,

                new ExecutorDelivery(new Handler(Looper.getMainLooper())));

    }

4个NetworkDispatcher,启了4个线程，不停的轮训请求队列

for (int i = 0; i < mDispatchers.length; i++) {

            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,

                    mCache, mDelivery);

            mDispatchers[i] = networkDispatcher;

            networkDispatcher.start();

        }

NetworkDispatcher extends Thread

03  不断从队列里取request，执行，分发

while (true) {

 request = mQueue.take();			//从队列取

 NetworkResponse networkResponse = mNetwork.performRequest(request);

 mDelivery.postResponse(request, response);

}

ExecutorDelivery implements ResponseDelivery

04  通过那个handler把response传递给UI线程

mResponsePoster = new Executor() {

            @Override

            public void execute(Runnable command) {

                handler.post(command);

            }

        };

mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));

mRequest.deliverResponse(mResponse.result);

然后一个Request实现，比如StringRequest

05

@Override

    protected void deliverResponse(String response) {

        mListener.onResponse(response);

    }

Volley.newRequestQueue(SportsApp.getContext());发生了什么？

尼玛，线程池＋while(true)。好意思问！

你为什么敢在onResponse(BaseParser response)里更新UI？

尼玛，万恶的handler，万恶的looper

2 Volley与HttpUrlConnection什么关系？

Volley.java

new newRequestQueue()的时候

if (Build.VERSION.SDK_INT >= 9) {

                stack = new HurlStack();

            } else {

                // Prior to Gingerbread, HttpUrlConnection was unreliable.

                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html

                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));

            }

3 出错重试机制  DefaultRetryPolicy

基于连接时间的

int timeoutMs = request.getTimeoutMs();

        connection.setConnectTimeout(timeoutMs);

        connection.setReadTimeout(timeoutMs);

4 缓存机制 CacheDispatcher

final Request<?> request = mCacheQueue.take();//把之前的请求存了

6 异常机制

VolleyError

https://github.com/mcxiaoke/android-volley/blob/master/src/main/java/com/android/volley/VolleyError.java

https://github.com/mcxiaoke/android-volley/blob/master/src/main/java/com/android/volley/NetworkError.java

7  请求优先机制

AtomicInteger mSequenceGenerator = new AtomicInteger();

request.setSequence(getSequenceNumber());

Request<T> implements Comparable<Request<T>>

先比较enum Priority

相同再比较Sequence

8 debugging / log

mEventLog.add(tag, Thread.currentThread().getId());

9 用到的结构

PriorityBlockingQueue<Request<?>> mCacheQueue

PriorityBlockingQueue<Request<?>> mNetworkQueue//使用者add进来的request

5

Volleye的线程机制是 ： 4个线程，不停的轮训请求队列

AsyncTask    内部是:3.0前是一个ThreadPoolExecutor，线程数跟CPU有关。3.0后是一个worker线程

ThreadPoolExcutor

java.util.concurrent的概念

Runnable   一个可执行单元

Executor 	可执行单元的执行器

https://github.com/mcxiaoke/android-volley/blob/master/src/main/java/com/android/volley/ExecutorDelivery.java

Volley http://www.jianshu.com/p/9e17727f31a1 

RequestQueue
用来管理各种请求队列，其中包含有4个队列
a) 所有请求集合，通过RequestQueue.add()添加的Request都会被添加进来，当请求结束之后删除。
b) 所有等待Request，这是Volley做的一点优化，想象一下，我们同时发出了三个一模一样的Request，此时底层其实不必真正走三个网络请求，而只需要走一个请求即可。所以Request1被add之后会被调度执行，而Request2 和Request3被加进来时，如果Request1还未执行完毕，那么Request2和 Request3只需要等着Request1的结果即可。
c) 缓存队列，其中的Request需要执行查找缓存的工作
d) 网络工作队列 其中的Request需要被执行网络请求的工作

NetworkDispatcher
执行网络Request的线程，它会从网络工作队列中取出一个请求，并执行。Volley默认有四个线程作为执行网络请求的线程。

CacheDispatcher
执行Cache查找的线程，它会从缓存队列中取出一个请求，然后查找该请求的本地缓存。Volley只有一个线程执行Cache任务。

内存缓存：缓存队列里是请求，缓存里是实体，实体是否超时决定是否重新请求。

ResponseDelivery
请求数据分发器，可以发布Request执行的结果。





